#' @import utils
## quiets concerns of R CMD check re: the .'s that appear in pipelines
#if(getRversion() >= "2.15.1")  utils::globalVariables(c(".",">"))
if(getRversion() >= "2.15.1")  utils::globalVariables(c(".",":=",".x",">"))

###################################################################
#' Infer Hconfig posteriors
#'
#' @param pValMat A matrix of p-values, each column corresponding to a p-value serie.
#' @param EffectMat A matrix of estimated effects corresponding to the p-values contained in pValMat. If specified, the procedure will account for the direction of the effect. (optional, default is NULL)
#' @param Hconfig A list of all possible combination of H0 and H1 hypotheses generated by the [GetHconfig()] function.
#' @param copula A string specifying the form of copula to use. Possible values are "indep"and "gaussian". Default is "indep" corresponding to the independent case. 
#' @param threads_nb The number of threads to use. The number of thread will set to the number of core available by default.
#' @param plotting A boolean. Should some diagnostic graphs be plotted ? Default is FALSE.
#' @param Precision The precision for EM algorithm to infer the parameters. Default is 1e-6. 
#' @import stats
#' @importFrom qvalue pi0est
#' 
#' @return  If the storage permits, a list containing:
#' Object 'prior' is a vector of estimated prior probabilities for each of the H-configurations.
#' Object 'posterior' is a matrix providing for each item (in row) its posterior probability to belong to each of the H-configurations (in columns).
#' Object 'fHconfig' is a matrix containing config densities evaluated at each items, each column corresponding to a configurations.
#' Object 'Rcopula' is the estimated correlation matrix of the gaussian copula.(if applicable)
#' Object 'Hconfig' is the list of all configurations.
#' Else, a list containing:
#' Object 'prior' is a vector of estimated prior probabilities for each of the H-configurations.
#' Object 'f0Mat' is a matrix containing the evaluation of the marginal densities under H0 at each items, each column corresponding to a p-value serie.
#' Object 'f1Mat' is a matrix containing the evaluation of the marginal densities under H1 at each items, each column corresponding to a p-value serie.
#' Object 'F0Mat' is a matrix containing the evaluation of the marginal cdf under H0 at each items, each column corresponding to a p-value serie.
#' Object 'F1Mat' is a matrix containing the evaluation of the marginal cdf under H1 at each items, each column corresponding to a p-value serie.
#' Object 'fHconfig_sum' is a vector containing the sum over the configurations c of (w_c*psi_c) for each items.
#' Object 'Rcopula' is the estimated correlation matrix of the gaussian copula.(if applicable)
#' Object 'Hconfig' is the list of all configurations.
#' @export
#' 
#' @examples
#' data(PvalSets)
#' PvalMat <- as.matrix(PvalSets[,-3])
#' ## Build the Hconfig objects
#' Q <- 2
#' Hconfig <- GetHconfig(Q)
#'
#' ## Run the function
#' res.fit <- qch.fit(pValMat = PvalMat,Hconfig = Hconfig)
#'
#' ## Display the prior of each class of items
#' res.fit$prior
#'
#' ## Display the first posteriors
#' head(res.fit$posterior)

qch.fit <- function(pValMat,EffectMat=NULL,Hconfig,copula="indep",threads_nb=0, plotting=FALSE,Precision=1e-6){
  
  n <- nrow(pValMat)
  Q <- ncol(pValMat)
  
  #for numerical precision problems
  pValMat <- pValMat %>% as.matrix()
  
  pValMat[which(pValMat==0)] <- min(pValMat[which(pValMat!=0)])
  pValMat[which(pValMat==1)] <- max(pValMat[which(pValMat!=1)])
  
  ### Check the dimension
  
  
  ### Check parameters
  if(copula!="indep" & copula!="gaussian"){
    stop("Error. Copula must be 'indep' or 'gaussian'.")
  }
  if(copula=="gaussian" & !is.null(EffectMat)){
    stop("Error. The procedure cannot take account of the direction of effects with a copula other than indep.")
  }

  ## Memory management 
  if(n*(2**Q)*8 > 2e9){#if the storage requirement exceeds 2Go
    memory_management <- TRUE
  }else{memory_management <- FALSE}

  
  #### Zscores computation
  if(is.null(EffectMat)){
    XMat <- -qnorm(pValMat)
  }else{
    XMat <- -qnorm(pValMat/2)* sign(EffectMat)
  }
  
  #### Step 1: Marginal density estimation
  
  ## Get p0 estimates
  p0 <- rep(0, Q)
  for (q in 1:Q){
    p0[q] <- min(qvalue::pi0est(p=pValMat[,q],pi0.method = "bootstrap")$pi0,1-1/n)
  }
  SomeH1 <-  which(p0<1)
  NoH1 <- which(p0==1-1/n);
  if(length(NoH1)==1){
    message(paste("Pvalue serie",NoH1, "may have very few H1 (or a weird distribution)"))
  }
  if(length(NoH1)>1){
    message(paste("Pvalue series",paste(NoH1,collapse=' '), "may have very few H1 (or a weird distribution)"))
  }
  
  ## Fit a 2-component mixture to each test serie using kerFdr
  f1Mat <- matrix(1, n, Q)
  F1Mat <- matrix(1, n, Q)
  if(is.null(EffectMat)){
    for(q in SomeH1){
      ker <- FastKerFdr_unsigned(XMat[, q], p0=p0[q], plotting)
      f1Mat[,q] <- ker$f1
      F1Mat[,q] <- ker$F1
      p0[q] <- ker$p0
    }
  }else{
    for(q in SomeH1){
      ker <- FastKerFdr_signed(XMat[, q], p0=p0[q], plotting=FALSE)
      f1Mat[,q] <- ker$f1
      F1Mat[,q] <- ker$F1
      p0[q] <- ker$p0
    }
    f1_signed <- f1_separation_signed(XMat,f0Mat,f1Mat,p0,plotting)
  }
  
  f0Mat <- matrix(dnorm(XMat),ncol=Q)
  F0Mat <- pnorm(XMat,mean = 0,sd = 1)
  
  #for numerical precision problems
  F0Mat[which(F0Mat>1-1e-12)] <- 1-1e-12
  F0Mat[which(F0Mat<1e-12)] <- 1e-12
  F1Mat[which(F1Mat>1-1e-12)] <- 1-1e-12
  F1Mat[which(F1Mat<1e-12)] <- 1e-12
  
  
  #### Step 1bis: transform marginal densities into config densities
  
  Logf0Mat <- log(f0Mat)
  if(is.null(EffectMat)){
    Logf1Mat <- log(f1Mat)
    if(!memory_management){
      fHconfig <- sapply(Hconfig, function(h){
        f <- rep(0,nrow(Logf0Mat))
        if (length(which(h==1)) > 0){f <- f + rowSums(Logf1Mat[, which(h==1), drop=FALSE])}
        if (length(which(h==0)) > 0){f <- f + rowSums(Logf0Mat[, which(h==0), drop=FALSE])}
        return(exp(f))
      })
    }
  }else{
    Logf1plusMat <- log(f1_signed$f1plusMat)
    Logf1minusMat <- log(f1_signed$f1minusMat)
    if(!memory_management){
      fHconfig <- sapply(Hconfig, function(h){
        f <- rep(0,nrow(f0Mat))
        if(length(which(h=="+")) > 0){f <- f + rowSums(Logf1plusMat[, which(h=="+"), drop=FALSE])}
        if(length(which(h=="-")) > 0){f <- f + rowSums(Logf1minusMat[, which(h=="-"), drop=FALSE])}
        if(length(which(h==0)) > 0){f <- f + rowSums(Logf0Mat[, which(h==0), drop=FALSE])}
        return(exp(f))
      })
    }
  }
  
  #### Step 2: Infer parameters using an EM procedure
  
  ## Initialization: 
  # Weights: Simple product of marginal priors estimator
  if(is.null(EffectMat)){
    NewPrior <- sapply(1:length(Hconfig), function(c){
      prod(p0[which(Hconfig[[c]]==0)]) * prod(1-p0[which(Hconfig[[c]]==1)])
    })
  }else{
    NewPrior <- sapply(1:length(Hconfig), function(c){
      prod(p0[which(Hconfig[[c]]==0)]) * prod(f1_signed$p1plus[which(Hconfig[[c]]=='+')]) * prod(f1_signed$p1minus[which(Hconfig[[c]]=='-')])
    })
  }
  
  
  # Copula parameters: Kendall's tau estimator
  if(copula=="gaussian"){
    NewRho <- copula::fitCopula(copula = copula::normalCopula(dim = Q,dispstr="un"),data = pValMat[sample(1:n,size=1e4),],method="itau") %>% coef()
    NewR <- copula::p2P(param = NewRho,d = Q)
  }
  
  ## EM calibration
  if(copula=="indep"){
    if(!memory_management){
      EM.res <- EM_calibration_indep(fHconfig = fHconfig,
                                     Prior.init = NewPrior,
                                     Precision = Precision)
    }else{
      EM.res <- EM_calibration_indep_memory(Logf0Mat = Logf0Mat,
                                            Logf1Mat = Logf1Mat,
                                            Prior.init = NewPrior,
                                            Hconfig = Hconfig,
                                            threads_nb = threads_nb,
                                            Precision = Precision )
    }
    
  }else if(copula=="gaussian"){
    if(!memory_management){
      EM.res<- EM_calibration_gaussian(Hconfig = Hconfig,
                                       F0Mat = F0Mat,
                                       F1Mat = F1Mat,
                                       fHconfig = fHconfig,
                                       R.init = NewR,
                                       Prior.init = NewPrior,
                                       Precision = Precision)
    }else{
      EM.res <- EM_calibration_gaussian_memory(Logf0Mat = Logf0Mat,
                                               Logf1Mat = Logf1Mat,
                                               F0Mat = F0Mat,
                                               F1Mat = F1Mat,
                                               Prior.init = NewPrior,
                                               R.init = NewR,
                                               Hconfig = Hconfig,
                                               threads_nb = threads_nb,
                                               Precision = Precision)
    }
    
  }
  
  #### Step 2bis: Posterior computation
  if(!memory_management){
    if(copula=="gaussian"){
      fcopula.Hconfig <- Copula.Hconfig_gaussian_density(Hconfig, F0Mat, F1Mat, EM.res$Rcopula) * fHconfig
      posterior <- fcopula.Hconfig*(tcrossprod(rep(1:n),EM.res$priorHconfig))
      posterior <- posterior/rowSums(posterior)
    }else if(copula=="indep"){
      posterior <- fHconfig*(tcrossprod(rep(1:n),EM.res$priorHconfig))
      posterior <- posterior/rowSums(posterior)
    }
  }else{
    if(copula=="gaussian"){
      RcopulaInv <- solve(EM.res$Rcopula)
      zeta0 <- qnorm(p = F0Mat,mean = 0,sd = 1)
      zeta1 <- qnorm(p = F1Mat,mean = 0,sd = 1)
      fHconfig_sum <- fHconfig_sum_update_gaussian_copula_ptr_parallel(Hconfig,
                                                                       EM.res$priorHconfig,
                                                                       Logf0Mat,Logf1Mat,
                                                                       zeta0,zeta1,
                                                                       EM.res$Rcopula,RcopulaInv,
                                                                       threads_nb = threads_nb) 
    }else if(copula=="indep"){
      fHconfig_sum <- fHconfig_sum_update_ptr_parallel(Hconfig,
                                                       EM.res$priorHconfig,
                                                       Logf0Mat,Logf1Mat,
                                                       threads_nb = threads_nb)
    }
  }
  
  
  #### Last but not least: output results
  if(!memory_management){
    Res <- list(prior=EM.res$priorHconfig,
                posterior=posterior,
                fHconfig=fHconfig,
                Rcopula = EM.res$Rcopula,
                Hconfig = names(Hconfig))
  }else{
    Res <- list(prior=EM.res$priorHconfig,
                f0Mat=f0Mat,f1Mat=f1Mat,
                F0Mat=F0Mat, F1Mat=F1Mat,
                fHconfig_sum=fHconfig_sum,
                Rcopula=EM.res$Rcopula,
                Hconfig = names(Hconfig))
  }
  
  return(Res)
  
}
